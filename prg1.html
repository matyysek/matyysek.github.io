<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="style1.css">
    <title>Project X</title>
</head>
<body>
    <div class="header">
        <img src="obrazky/logo_sps.png" alt="Logo školy" height="50" width="50" align="left">
        <h1 class="hlavickaText">Střední průmyslová škola Česká Lípa - Maturita</h1>
    </div>

  <div class="topnav">
    <a class="active" href="main.html"><i class="fa fa-home"></i></a>
    <a href="cj.html">ČJ</a>
    <a href="cjr.html">ČJ - Rozbory</a>
    <a href="mat.html">MAT</a>
    <a href="mit.html">MIT</a>
    <a href="asw.html">ASW</a>
    <a href="ops.html">OPS</a>
    <a href="pos.html">POS</a>
    <a href="prg.html">PRG</a>
    <a href="prg.html">AJ</a>
  </div>

	<div class="sidenav">
  		<a href="prg1.html">Algoritmizace</a>
  		<a href="prg2.html">Datové struktury</a>
  		<a href="prg3.html">Vývojové diagramy, UML</a>
      <a href="prg4.html">Vyhledávací a třídící algoritmy</a>
      <a href="prg5.html">Strukturované programování</a>
      <a href="prg6.html">Objektově orientované programování</a>
      <a href="prg7.html">Událostmi řízené programování</a>
      <a href="prg8.html">Webové aplikace</a>
	</div>

	<div class="content">
  	<h1>Algoritmizace</h1>

    <h3>Algoritmizace</h3>
		<p>Algoritmizace je činnost(postup), sloužící k sestavení algoritmu.</p>

    <h3>Vstup a výstup algoritmizace</h3>
    <p>Vstupem je zadání úlohy či problému a výstupem je postup, jak danou úlohu vyřešit.</p>

    <h3>Algoritmus</h3>
    <p>Algoritmus je postup-posloupnost operací, které řeší danou úlohu.</p>

    <h3>Zápis algoritmu</h3>
    <p>Zápis algoritmu můžeme udělat různými způsoby. Grafiky pomocí vývojového diagramu nebo kopenogramem(strukturogramem). Slovně v přirozeném jazyce. Matematicky formálně pomocí symbolů(vztahem mezi veličinami, soustavou rovnic) a jako poslední programovacím jazykem(využití jen jednoduchých úloh).</p>

    <h3>Vlastnosti algoritmu</h3>
    <p>Determinovanost - jednoznačnost</br> 
    Každý krok algoritmu - jednoznačné a přesně definované </br>
    Pro stejné stupy = stejný výsledek </br>
    Neplatí pro programy které využívají náhody</p>
    <p>Resultativnost - výstup </br>
    Algoritmus má aspoň jeden výstup </br>
    V požadovaném vztahu k zadání vstupům, tvoří odpověď na problém </br>
    Algoritmus vede od zpracování hodnot do vstupu k výstupu</p>
    <p>Hromadnost – obecnost </br>
    Algoritmus neřeší konkrétní případ problémů, ale obecnou třídu daných problémů </br>
    Algoritmus musí řešit danou úlohu pro různé vstupní hodnoty</p>
    <p>Konečnost </br>
    Algoritmus musí končit v konečném počtu kroků </br>
    Počet může být libovolně velký podle rozsahu úlohy ale vstup musí být konečný </br>
    Algoritmy, které to nesplňují se nazývají výpočetní metody</p>
    <p>Srozumitelnost a přehlednost efektivnosti </br>
    Vybíráme podle kritérií, který algoritmus řeší úlohu nejefektivněji </br>
    Časové, paměťové, přehlednost, srozumitelnost</p>

    <h3>Časová a paměťová složitost algoritmu</h3>
    <p>Časová složitost je doba výpočtu podle daného algoritmu potřebná pro zpracování dané úlohy </br>
    Paměťová složitost se určuje podle velikosti paměti využívané při výpočtu</p>

    <h3>Turingův stroj, princip a části</h3>
    <p>Turingův stroj je zařízení, které se používá ke studiu vypočitatelnosti. Ke zjištění, které problémy s jeho využitím lze řešit a které ne. </br>

    Na začátku výpočtu je Turingův stroj v počáteční konfiguraci a na pásce je zapsané vstupní slovo. Dále pracuje v jednotlivých krocích: </br>

    pokud je aktuální stav zároveň stavem koncovým, výpočet končí </br>

    čtecí hlava přečte jeden vstupní symbol z buňky, na které se právě nachází </br>

    pokud je v přechodové funkci pro aktuální stav a pro přečtený symbol definovaný přechod, provede se (v případě více možných přechodů u nedeterministických strojů se vybere jeden náhodně): </br>

    změní se stav </br>

    na aktuální pozici hlavy se zapíše příslušný symbol </br>

    hlava se příslušným způsobem posune (či neposune) </br>

    Skládá se z procesorové jednotky, tvořené konečným automatem, programu ve tvaru pravidel, přechodové funkce a pravostranně nekonečné pásky pro zápis mezivýslednků.</p>

    <h3>Vztahy mezi Markovovým algoritmem, modelem RAM a Turingovým strojem</h3>
    <p>Markovské rozhodovací procesy jsou rozšířením Markovských řetězců; rozdíl je v přidání akcí (umožňují výběr) a užitků (motivace). Pokud by existovala pouze jedna akce, nebo pokud by byla daná uskutečnitelná akce stejná pro všechny stavy, Markovský rozhodovací proces by se zredukoval na Markovský řetězec.</p>
    <p>RAM stroje už vycházejí ze skutečných počítačů. RAM stroje mají paměť, pracují s přirozenými čísly (1,2,3,...) a   instrukce se podobají klasickýcm příkazům. Buňky paměti jsou oadresovány čísly 0 - ∞, přičemž první registr [0] se bere jako pracovní registr a registr [1] je indexový registr (pouzívá se u příkazu s hvězdičkou).</p>
    <p>Na začátku výpočtu je Turingův stroj v počáteční konfiguraci a na pásce je zapsané vstupní slovo.</p>

    <h3>Tři typy úloh řešené algoritmem</h3>
    <p>Dynamické programování funguje obdobně jako hladový algoritmus, ale negeneruje se pouze jedna posloupnost. Zkoumají se všechny posloupnosti, které by mohly být optimální a vylučují se ty, které optimální nebudou. Používají se dílčí výsledky, které byly získané již dříve během výpočtu. 

    Velice přímočarý přístup k řešení určité třídy optimalizačních úloh.</p>
    <p>Zpracovává se množina V složená z n údajů. Úkolem je najít podmnožinu W množiny V, která vyhovuje určitým podmínkám a přitom optimalizuje předepsanou účelovou funkci. Jakákoliv množina W, vyhovující daným podmínkám, se nazývá přípustné řešení. Přípustné řešení, pro které nabývá účelová funkce optimální hodnoty, se nazývá optimální řešení.</p>
    <p>Hledání s návratem založené na prohledávání stavového prostoru problému. Též se nazývá metoda pokusů a oprav, metoda zpětného sledování, metoda prohledávání do hloubky.</p>

    <h3>Asymptotická složitost</h3>
    <p>Asymptotická složitost je způsob klasifikace počítačových algoritmů. Určuje operační náročnost algoritmu tak, že zjišťuje, jakým způsobem se bude chování algoritmu měnit v závislosti na změně velikosti (počtu) vstupních dat.</p>

    <h3>Klíčová slova v programovacím jazyce</h3>
    <p>Klíčové slovo má specifický význam v programovacím jazyce. Významy klíčových slov se v různých jazycích liší. Často se užívají v programovacím jazyce C a C++. V tomto jazyce identifikuje syntaktickou formu. Slova, která se v programování používají, jsou velmi často anglická. Díky původním klíčovým slovům můžeme v programovacím jazyce vytvářet nová slova a jsme tak schopni psát programy. </br>

    Dále se klíčová slova používají v programech Basic, Java, Pascal, PHP.</p>

    <h3>Syntaxe programovacího jazyka</h3>
    <p>V informatice je syntaxe programovacího jazyka soubor pravidel, která definují kombinaci symbolů, které jsou považovány za správně strukturovaný dokument nebo fragment v tomto jazyce. To platí jak pro programovací jazyky, kde dokument představuje zdrojový kód, tak pro značkovací jazyky, kde dokument představuje data. Syntaxe jazyka definuje jeho povrchovou formu. Textové programovací jazyky jsou založeny na posloupnosti znaků, zatímco vizuální programovací jazyky jsou založeny na prostorovém uspořádání a spojení mezi symboly (které mohou být textové nebo grafické). Dokumenty, které jsou syntakticky neplatné, obsahují syntaktickou chybu.</p>

    <h3>Vyšší programovací jazyky</h3>
    <p>Vyšší programovací jazyky se více blíží k člověku a běžnému jazyku který používáme. </p>

    <h3>Nižší programovací jazyky</h3>
    <p>Nižší programovací jazyky si rozumí více s počítačem a člověk jim hůře rozumý. </p>

    <h3>Příklady nižších a vyšších programovacích jazyků a zdůvodnění</h3>
    <p>Příklady višších jazyků: C, C++, Pascal, Basic </br>
    Příklady nižších jazyků: JSA, Asembler</p>

    <h3>Vznik program</h3>
    <p>Nejprve je nutno napsat zdrojový kód programu, tedy kód např. v jazyce C#. Daný kód se poté zkompiluje či je překládán interpretem do strojového kódu, se kterým následně pracuje procesor počítače.</p>

    <h3>Překladač</h3>
    <p>Překladač je program, který překládá soubor se zdrojovým kódem na soubor se strojovým kódem.</p>

    <h3>Interpret</h3>
    <p>Interpret je program, který překládá zdrojový kód jednu instrukci(příkaz) po druhé na strojový kód.</p>

    <h3>Strojový kód</h3>
    <p>Strojový kód jsou instrukce algoritmu v podobě, které dokáže vykonat přímo daný stroj – počítač. Je to algoritmus zapsaný ve strojovém kódu.</p>

    <h3>Rozdíl mezi interpretovanými a kompilovanými programovacími jazyky</h3>
    <p>Interpretovaný </br>

    Pro spuštění programu je nutný interpret, tedy program vykonávající jednotlivé příkazy programu. Většinou je paměťově náročnější.</p>
    <p>Kompilovaný </br>

    Zdrojový kód je nutné přeložit pouze jednou, poté lze spouštět bez nutnosti externího programu.</p>

    <h3>Rozdíl mezi funkcí a procedurou</h3>
    <p>Rozdíl mezi procedurou a funkcí je ten, že procedura prostě jen vykoná svoje příkazy, zatímco funkce vykoná příkazy, a navíc je jejím výsledkem nějaká hodnota (u funkce musí být jako u proměnné daný typ - to je právě typ její výsledné hodnoty).</p>

    <h3>Vznik syntaktické a logické chyby a projevení</h3>
    <p>Syntaticka: Taková chyba spočívá v narušení syntaxe gramatiky použitého programovacího jazyka. U kompilovaných programů ji překladač zahlásí přímo při překladu během syntaktické analýzy.</p>
    <p>Logicka: nejzávažnější chyby, kterých se programátor může dopustit. Tyto chyby jsou závažné tím, že často nemají žádné bezprostřední symptomy nebo se projevují pouze nepřímo. Z pohledu překladače ani JVM nedojde k žádné nestandardní situaci a programu je povoleno pokračovat. Podstatou chyby je rozpor mezi tím, co má program dělat, a tím, jak byl naprogramován.</p>

    <h3>Popis v krocích vývojový cyklus software</h3>
    <p>Požadavky </br>

    Řeší se, jakou úlohu bude program řešit, kde bude využíván a pro koho bude určen.</p>
    <p>Specifikace </br>

    Popisování funkčnosti požadovanéhoprogramu. Využívá se pomůcek jako grafů, obrázků atp.</p>
    <p>Architektura </br>

    Navrhuje se, jak bude program fungovat jako celek. Program se rozděluje na moduly či vrstvy. Závislé na programovacím jazyce.</p>
    <p>Návrh </br>

    Detailní popis všech částí programu. Závislé na programovacím jazyce.</p>
    <p>Vytvoření </br>

    Vytvoření samotného programu podle předešlých kroků.</p>
    <p>Testování a ladění </br>

    Program se testuje, zda-li je funkční a vše funguje beze chyb. Pokud program nesplňuje požadavky, je nutné ho upravit.</p>
    <p>Použití </br>

    Pokud vše funguje, program je možno poskytnout uživatelům.</p>

    <h3>Algoritmizace úlohy pro strukturovaný programovací jazyk</h3>
    <p>Jakýkoli algoritmus lze zapsat pomocí těchto příkazů: </br>

    posloupnost příkazů </br>

    neúplný podmíněný příkaz </br>

    úplný podmíněný příkaz </br>

    cyklus s podmínkou před posloupností </br>

    cyklus s podmínkou za posloupností </br>

    cyklus řízený parametrem</p>

    <h3>Algoritmizace úlohy pro objektově orientovaný jazyk</h3>
    <p>Je nutno rozložit logiku programu na jednotlivé spolu provázané objekty.</p>

    <h3>Rozdíl mezi algoritmizací ve strukturovaném programovacím jazyce a objektově orientovaném jazyce</h3>
    <p>Strukturovaně </br>

    Program se člení do funkcí či procedur.</p>
    <p>Objektově </br>

    Program se člění do objektů, které dále mají metody s různým modifikátorem přístupu.</p>

    <h3>Použití konstrukce u algoritmizace ve strukturovaném programovacím jazyce</h3>
    <p>Jakýkoli algoritmus lze zapsat pomocí těchto příkazů: </br>

    posloupnost příkazů </br>

    neúplný podmíněný příkaz </br>

    úplný podmíněný příkaz </br>

    cyklus s podmínkou před posloupností </br>

    cyklus s podmínkou za posloupností </br>

    cyklus řízený parametrem</p>

    <h3>Použití konstrukce u algoritmizace objektově orientovaném programovacím jazyce</h3>
    <p>Využívá se objektů a tříd. Objekty se mohou dále modifikovat pomocí dědičnosti, skládání, zapouzdření atp.</p>

    <h3>Návrhové vzory</h3>
    <p>Návrhové vzory představují řešení návrhu programu. Jedná se o vyzkoušený postup, ne o knihovnu či kus kódu. Řeší návrh, ne konkrétní problém.</p>

    <h3>Vztahy mezi návrhovými vzory a algoritmizací</h3>
    <p>Algorizace bere v potaz návrhový vzor, kterým se musí řídit, aby se zachovala jednotnost v rámci programu. Návrhový vzor je jakousi šablonou pro algoritmizaci.</p>

    <h3>Způsoby, jakými lze testovat správnou funkci programů nebo software</h3>
    <p>Statické testování nevyžaduje běh softwaru, proto je možné s ním začít ještě před vytvořením prvního prototypu: I dokumentace je předmětem testování. Lze ho s výhodou provádět ještě před začátkem psaní kódu, výsledkem pak může být například zpřesnění odhadů náročnosti na čas (člověkohodiny, estimates) a zdroje (strojohodiny a počet strojů) pro samotný nadcházející vývoj.</p>
    <p>Dynamické testování vyžaduje existenci spustitelné verze softwaru a probíhá hlavně na základě poskytování různých vstupů (anebo i neposkytování žádných) a posuzování výstupů (i jejich samé existence) testovaného programu.</p>

	</div>

</body>
</html> 